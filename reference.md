---
author: lunar
date: Wed 23 Sep 2020 06:31:43 PM CST
---

### 左值引用与右值引用

左值：可以取地址的，有名字的，非临时的就是左值；

右值：不能取地址，没有名字的，临时的就是右值。

左值的英文缩写为"lvalue", 右值的英文缩写为"rvalue"。这并非很多人认为的"left value"和"right value"。而是"localtor value"和"read value"，分别表示可以在内存中找到的值和只能提供数值的值。

左值引用即我们常见的定义引用的方式，引用就相当于变量的别名。

左值引用要求右值必须能够取地址，如果不能取地址，则必须为常引用。

因为左值引用本质上是将地址赋给左值，所以下面的这种语句不能出现：
`int &b = a + 1;`

因为`a+1`不能被认为一个在内存中存在地址的变量，它只是一个数。当然如果加上const修饰符就可以了。

又或者下面这种:
```c++
int func() {
    return 0;
}

int &i = func();
```
函数`func()`的返回值也是右值，在内存中没有具体的地址。

那如果我们想要保存一个函数的返回值的话，要么通过常引用，要么不适用引用。前者导致引用不可修改，后者常常会带来大代价的拷贝函数调用。

如果我们即想引用可以修改，又想不带来内存拷贝的代价的话，就可以使用右值引用了。

右值引用的定义格式如下：
`类型 &&引用名 = 右值表达式;`

右值引用可以延长临时变量的生存周期，避免了无谓的内存复制操作。

#### 移动语义

需要注意的是，右值引用的右端并不能是左值，比如下面的操作是不被允许的：
```c++
int d = 1;
int &&r = d;
```

如果想要实现这样的操作，可以借助标准库里面的`move`函数。
```c++
int &&r = std::move(d);
```

你可能觉得这样做没有必要，明明使用左值引用就可以解决的事情，为什么还要用右值引用呢？

那是在你知道右端是左值的情况下。如果右端传入的数不确定是左值还是右值的话，`std::move`函数的应用场景就显现了，这样就省去了你判断右端是左值还是右值的功夫。
